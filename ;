// Copyright 2024, Texas A&M University
//
//
// This file is part of AMCSET.
//
// AMCSET is free software: you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the Free Software
// Foundation, either version 3 of the License, or (at your option) any later
// version.
//
// AMCSET is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// AMCSET. If not, see <https://www.gnu.org/licenses/>.

#include "amcset_common.h"

#include <boost/units/systems/si/amount.hpp>
#include <boost/units/systems/si/codata/physico-chemical_constants.hpp>
#include <boost/units/systems/si/energy.hpp>
#include <boost/units/systems/si/length.hpp>
#include <glog/logging.h>

#include <boost/random/discrete_distribution.hpp>
#include <boost/random/mersenne_twister.hpp>
#include <boost/random/uniform_01.hpp>

#include <boost/units/cmath.hpp>
#include <boost/units/pow.hpp>
#include <boost/units/static_rational.hpp>
#include <boost/units/systems/si/mass.hpp>

#include <cmath>
#include <numeric>
#include <stdexcept>

#include "amcset_utilities.h"

namespace amcset {
namespace common {

// Layer function implementations{{{
Layer::Layer(material_vector &&material, length_quantity depth,
             mass_density_quantity mass_density) try
    : material_([&material, depth, mass_density]() {
        VLOG(1) << "Creating Layer material with vector of length "
                << material.size() << ", depth " << depth << ", and density "
                << mass_density;
        auto relative_compositions =
            material | std::views::transform(
                           &std::pair<double, Particle::Properties>::first);
        double sum = std::accumulate(relative_compositions.begin(),
                                     relative_compositions.end(), 0.0);
        VLOG(1) << "Sum of compositions is " << sum;

        for (auto &pair : material) {
          if (pair.first < 0) {
            throw std::invalid_argument(EXCEPTION_MESSAGE(
                "Relative composition: " + std::to_string(pair.first) +
                " is less than zero."));
          }
          VLOG(2) << "Initial composition is " << pair.first;
          pair.first /= sum;
          VLOG(2) << "Final composition is " << pair.first;
        }

        return std::move(material);
      }()),
      depth_(depth), mass_density_(mass_density), number_density_([&]() {
        VLOG(1) << "Calculating mass density using " << mass_density;
        return mass_density /
               (std::accumulate(material_.begin(), material_.end(),
                                mass_quantity(0),
                                [](const mass_quantity &sum, const auto &mat) {
                                  VLOG(2)
                                      << "Number density calculation. Sum of "
                                      << sum << ", fraction " << mat.first
                                      << ", and mass of " << mat.second.mass_;
                                  return sum + mat.first * mat.second.mass_;
                                }) *
                constants::N_A);
      }()) {
  VLOG(1) << "Created Layer with " << material_.size()
          << " components, depth of " << depth << ", density of "
          << mass_density << ", and number density of " << number_density_;

  if (depth < length_quantity(0)) {
    throw std::invalid_argument(EXCEPTION_MESSAGE("Depth: " + to_string(depth) +
                                                  " is less than zero."));
  }

  if (material_.size() == 0) {
    throw std::invalid_argument(EXCEPTION_MESSAGE(
        "Cannot pass a vector of size 0 to Layer constructor"));
  }

  VLOG(1) << "Passing relative compositions to discrete distribution.";
  auto composition_view = get_relative_compositions();
  discrete_distribution_ = boost::random::discrete_distribution<size_t, double>(
      composition_view.begin(), composition_view.end());

} catch (...) {
  rethrow();
}

auto Layer::get_relative_compositions() const
    -> decltype(std::declval<const material_vector &>() |
                std::views::keys) try {
  VLOG(1) << "Getting relative compositions for layer with " << material_.size()
          << " components";
  // return material_ |
  //        std::views::transform(&std::pair<double,
  //        Particle::Properties>::first);
  return material_ | std::views::keys;
} catch (...) { //!<
  rethrow(EXCEPTION_MESSAGE(""));
} // }}}

// Volume function implementations{{{
Volume::Volume(std::vector<Layer> &&layers) try : layers_(std::move(layers)) {
  VLOG(1) << "Created volume with " << layers_.size() << " layers.";
  if (layers_.size() == 0) {
    throw std::invalid_argument(
        "Vector cannot be empty to Volume constructor.");
  }

  auto prev_depth = layers_.at(0).get_depth();
  for (const auto &layer : layers_) {
    if (layer.get_depth() < prev_depth) {
      throw std::invalid_argument(EXCEPTION_MESSAGE(
          "Provided vector of layers contains a layer which has a "
          "smaller "
          "depth than the previous layer. Depth: " +
          to_string(layer.get_depth()) +
          ". Previous depth: " + to_string(prev_depth)));
    }
  }
} catch (...) {
  rethrow();
}

const Layer &Volume::get_layer(size_t index) const try {
  if (index > layers_.size()) {
    throw std::out_of_range(EXCEPTION_MESSAGE(
        "Index out of range. Index: " + std::to_string(index) +
        ". Vector size: " + std::to_string(layers_.size())));
  }
  return layers_[index];
} catch (...) {
  rethrow();
}

std::pair<const Layer *, size_t> Volume::get_layer(length_quantity depth) const
    try {
  VLOG(1) << "Getting layer at depth " << depth;
  if (depth < length_quantity(0.0 * angstrom)) {
    throw std::invalid_argument(EXCEPTION_MESSAGE(
        "Depth: " + to_string(depth) + " cannot be less than zero."));
  }

  if (depth > layers_.back().get_depth()) {
    throw std::out_of_range(EXCEPTION_MESSAGE(
        "Depth: " + to_string(depth) + " is deeper than the deepest layer."));
  }

  // Rely on the ordering of the layers (depths are strictly increasing)
  for (size_t i = 0; i < layers_.size(); i++) {
    VLOG(2) << "Checking layer " << i << " with depth "
            << layers_[i].get_depth();
    if (depth <= layers_[i].get_depth()) {
      VLOG(1) << "Found match at " << i << " with depth "
              << layers_[i].get_depth() << " greater than " << depth;
      return std::make_pair(&layers_[i], i);
    }
  }

  // There is a logic error if this is reached
  throw std::logic_error(
      EXCEPTION_MESSAGE("End of layer vector vector reached. Maximum depth: " +
                        to_string(layers_.back().get_depth()) +
                        ". Provided depth: " + to_string(depth)));
} catch (...) {
  rethrow();
} // }}}

// Simulation function implementations{{{
Simulation::Settings::Settings(
    energy_quantity electron_stopping_energy, size_t z_number,
    size_t mass_number, bool enable_damage_cascade,
    energy_quantity ion_stopping_energy,
    energy_quantity ion_displacement_energy, bool log_single_displacement,
    size_t divisor_angle_number, size_t flying_distance_number,
    length_quantity range, size_t bombardment_count, bool is_electron,
    energy_quantity incident_energy, size_t thread_count) try
    : electron_stopping_energy_(electron_stopping_energy), z_number_(z_number),
      mass_number_(mass_number),
      incident_particle_properties_(
          Particle::Properties(z_number, mass_number)),
      enable_damage_cascade_(enable_damage_cascade),
      ion_stopping_energy_(ion_stopping_energy),
      ion_displacement_energy_(ion_displacement_energy),
      log_single_displacement_(log_single_displacement),
      divisor_angle_number_(divisor_angle_number),
      flying_distance_number_(flying_distance_number), range_(range),
      bombardment_count_(bombardment_count), is_electron_(is_electron),
      incident_energy_(incident_energy), thread_count_(thread_count) {
  if (incident_energy <= energy_quantity(0.0 * kilo_electron_volt)) {
    throw std::invalid_argument(
        EXCEPTION_MESSAGE("Incident energy should be greater than 0. Value: " +
                          to_string(incident_energy)));
  }
  if (bombardment_count == 0) {
    throw std::invalid_argument(
        EXCEPTION_MESSAGE("Bombardment count must be greater than 0"));
  }
  if (divisor_angle_number == 0) {
    throw std::invalid_argument(
        EXCEPTION_MESSAGE("Divisor angle number must be greater than 0"));
  }
  if (ion_displacement_energy < energy_quantity(0.0 * kilo_electron_volt)) {
    throw std::invalid_argument(EXCEPTION_MESSAGE(
        "Ion displacement energy cannot be less than 0. Value: " +
        to_string(ion_displacement_energy)));
  }
  if (range < length_quantity(0.0 * angstrom)) {
    throw std::invalid_argument(EXCEPTION_MESSAGE(
        "Range cannot be less than 0. Value: " + to_string(range)));
  }
  if (flying_distance_number == 0) {
    throw std::invalid_argument(
        EXCEPTION_MESSAGE("Flying distance number must be greater than 0"));
  }
  if (electron_stopping_energy < energy_quantity(0.0 * kilo_electron_volt)) {
    throw std::invalid_argument(EXCEPTION_MESSAGE(
        "Electron stopping energy cannot be less than 0. Value: " +
        to_string(electron_stopping_energy)));
  }
  if (thread_count == 0) {
    throw std::invalid_argument(
        EXCEPTION_MESSAGE("Thread count must be greater than 0"));
  }
} catch (...) {
  rethrow();
}

Simulation::Simulation(const Settings settings, Volume &&volume) try
    : settings_(settings), volume_(std::move(volume)),
      thread_pool_(settings.thread_count_) {
  LOG(INFO) << "Creating simulation with settings:\n"
            << Simulation::print_settings(); // TODO: Print volume information
                                             // as well.
  std::vector<Bombardment> bombardments;
  bombardments.reserve(settings.bombardment_count_);

  for (size_t i = 0; i < settings.bombardment_count_; i++) {
    VLOG(1) << "Creating bombardment " << i;
    bombardments.push_back(Bombardment(*this, i));
  }
  bombardments_ = std::move(bombardments);
  LOG(INFO) << "Bombardments Created";

} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
}

int Simulation::run_simulation() try {
  LOG(INFO) << "Starting Simulation...";
  for (auto &bombardment : bombardments_) {
    // TODO: Enable multithreading
    // boost::asio::post(thread_pool_, [&bombardment]() {
    LOG(INFO) << "Starting Bombardment...";
    bombardment.run_bombardment();
    LOG(INFO) << "...Bombardment Complete!";
    // });
  }
  // thread_pool_.join();
  LOG(INFO) << "...Simulation complete";
  return 0;
} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
}

std::string Simulation::print_settings() const try {
  std::ostringstream ss;
  ss << "Electron stopping energy: " << settings_.electron_stopping_energy_
     << std::endl;
  ss << "Incident particle z number: " << settings_.z_number_ << std::endl;
  ss << "Incident particle mass number: " << settings_.mass_number_
     << std::endl;
  ss << "Incident particle properties: " << std::endl;
  ss << "\tMass: " << settings_.incident_particle_properties_.mass_
     << std::endl;
  ss << "\tCharge: " << settings_.incident_particle_properties_.charge_
     << std::endl;
  ss << "Enable damage cascade? "
     << (settings_.enable_damage_cascade_ ? "Yes" : "No") << std::endl;
  ss << "Ion stopping energy: " << settings_.ion_stopping_energy_ << std::endl;
  ss << "Ion displacement energy: " << settings_.ion_displacement_energy_
     << std::endl;
  ss << "Log single displacement? "
     << (settings_.log_single_displacement_ ? "Yes" : "No") << std::endl;
  ss << "Divisor angle number: " << settings_.divisor_angle_number_
     << std::endl;
  ss << "Flying distance number: " << settings_.flying_distance_number_
     << std::endl;
  ss << "Range: " << settings_.range_ << std::endl;
  ss << "Bombardment count: " << settings_.bombardment_count_ << std::endl;
  ss << "Is electron? " << (settings_.is_electron_ ? "Yes" : "No") << std::endl;
  ss << "Incident energy: " << settings_.incident_energy_ << std::endl;
  ss << "Thread count: " << settings_.thread_count_ << std::endl;
  return ss.str();
} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
} // }}}

// Bombardment function implementations{{{
Bombardment::Bombardment(const Simulation &simulation, size_t id) try
    : simulation_(simulation), random_number_generator_(),
      uniform_distribution_(), id_(id) {
  VLOG(1) << "Attempting random number: "
          << uniform_distribution_(random_number_generator_);

} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
}

void Bombardment::run_bombardment() try {
  if (simulation_.get_settings(&Simulation::Settings::is_electron_)) {
    VLOG(1) << "Simulating electron bombardment...";
    incident_particle_ = std::make_unique<Electron>(
        simulation_.get_settings(&Simulation::Settings::z_number_),
        simulation_.get_settings(&Simulation::Settings::mass_number_),
        simulation_, uniform_distribution_, random_number_generator_);
    VLOG(1) << "...Electron bombardment complete.";
  } else {
    VLOG(1) << "Simulating ion bombardment";
    incident_particle_ = std::make_unique<Ion>(
        simulation_.get_settings(&Simulation::Settings::z_number_),
        simulation_.get_settings(&Simulation::Settings::mass_number_),
        simulation_, uniform_distribution_, random_number_generator_);
    VLOG(1) << "...Ion bombardment complete.";
  }

  incident_particle_->fire();

} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
} // }}}

// Particle function implementations{{{
Particle::Particle(size_t z_number, size_t mass_number,
                   const Simulation &simulation,
                   boost::random::uniform_01<double> &uniform_distribution,
                   boost::random::mt19937 &random_number_generator) try
    : properties_(Particle::Properties(z_number, mass_number)),
      particles_(std::vector<std::unique_ptr<Particle>>()),
      coordinates_(std::vector<Coordinate>()), simulation_(simulation),
      velocity_(Velocity(
          0, 0,
          simulation.get_settings(&Simulation::Settings::incident_energy_))),
      coordinate_(Coordinate(0, 0, 0)),
      uniform_distribution_(uniform_distribution),
      random_number_generator_(random_number_generator) {
} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
}

velocity_quantity Particle::speed_from_energy(energy_quantity energy,
                                              mass_quantity mass) const {
  return boost::units::sqrt(2.0 * energy / mass);
}

mass_quantity Particle::reduced_mass(mass_quantity mass_1,
                                     mass_quantity mass_2) const {
  return mass_1 * mass_2 / (mass_1 + mass_2);
}

energy_quantity Particle::cm_energy(mass_quantity reduced_mass,
                                    velocity_quantity velocity) const {
  return reduced_mass * boost::units::pow<2>(velocity) / 2.0;
}

dimensionless_quantity
Ion::screening_function(dimensionless_quantity reduced_radius) const {
  const auto result = 0.1818 * exp(-3.2 * reduced_radius) +
                      0.5099 * exp(-0.9423 * reduced_radius) +
                      0.2802 * exp(-0.4028 * reduced_radius) +
                      0.2817 * exp(-0.2016 * reduced_radius);
  VLOG(2) << "Screening function with reduced radius " << reduced_radius
          << " is " << result;
  return result;
}

// TODO: Find a way to cache the results of this function for speedup. Consider
// calculating ahead of time and storing the results in a data structure
// constructed at runtime for each Layer material.
length_quantity Ion::screening_length(dimensionless_quantity z_1,
                                      dimensionless_quantity z_2) const {
  const auto result = 0.25 * cbrt(9.0 * pi * pi / 2.0) * bohr_radius /
                      (pow(z_1, 0.23) + pow(z_2, 0.23));
  VLOG(2) << "Screening length with z_1 " << z_1 << " and z_2 " << z_2 << " is "
          << result;
  return result;
}

energy_quantity Ion::screening_potential(length_quantity radius,
                                         dimensionless_quantity z_1,
                                         dimensionless_quantity z_2) const {
  auto reduced_length = radius / screening_length(z_1, z_2);
  auto result = screening_function(reduced_length) * z_1 * z_2 * e_statcoulomb *
                e_statcoulomb / radius;
  VLOG(2) << "Screening potential with radius " << radius << ", z_1 " << z_1
          << ", and z_2 " << z_2 << " is " << result;
  return result;
}

voltage_quantity
Ion::screening_potential_derivative(length_quantity radius,
                                    dimensionless_quantity z_1,
                                    dimensionless_quantity z_2) const {
  // TODO: Consolidate calls to screening_length to above-mentioned method.
  // Optimize this function as well.
  auto s_length = screening_length(z_1, z_2);
  auto reduced_radius = radius / s_length;
  auto result =
      (0.1818 * exp(-3.2 * reduced_radius) * (-3.2 / s_length) +
       0.5099 * exp(-0.9423 * reduced_radius) * (-0.9423 / s_length) +
       0.2802 * exp(-0.4028 * reduced_radius) * (-0.4028 / s_length) +
       0.2817 * exp(-0.2016 * reduced_radius) * (-0.2016 / s_length)) *
          z_1 * z_2 * e_statcoulomb * e_statcoulomb / radius -
      (0.1818 * exp(-3.2 * reduced_radius) +
       0.5099 * exp(-0.9423 * reduced_radius) +
       0.2802 * exp(-0.4028 * reduced_radius) +
       0.2817 * exp(-0.2016 * reduced_radius)) *
          z_1 * z_2 * e_statcoulomb * e_statcoulomb / (radius * radius);
  VLOG(2) << "Screening potential derivative with radius " << radius << ", z_1 "
          << z_1 << ", and z_2 " << z_2 << " is " << result;
  return result;
}

dimensionless_quantity Ion::reduced_energy(length_quantity screening_length,
                                           energy_quantity cm_energy,
                                           dimensionless_quantity z_1,
                                           dimensionless_quantity z_2) const {
  auto result = screening_length * cm_energy /
                (z_1 * z_2 * e_statcoulomb * e_statcoulomb);
  VLOG(2) << "Reduced energy with screening length " << screening_length
          << ", center of mass energy " << cm_energy << ", z_1 " << z_1
          << ", z_2 " << z_2 << ", result is " << result;
  return result;
}

// TODO: Verify that dividing by Avogadro's number is correct.
length_quantity
Ion::free_flying_path_length(mass_quantity m_1, mass_quantity m_2,
                             dimensionless_quantity reduced_energy,
                             length_quantity screening_length,
                             number_density_quantity number_density) const {
  length_quantity L;
  if (reduced_energy > 100) {
    L = (0.02 * pow(1.0 + (m_1 + m_2) / atomic_mass_unit, 2) * reduced_energy *
             reduced_energy +
         0.1 * pow(reduced_energy, 1.38)) /
        (4.0 * pi * screening_length * screening_length * number_density *
         log(1.0 + reduced_energy)) /
        si::constants::codata::N_A;
    VLOG(3) << "High energy free flying path length with m_1 " << m_1 << ", m_2"
            << m_2 << ", reduced_energy " << reduced_energy
            << ", screening_length " << screening_length
            << ", and number_density " << number_density << " with result "
            << L;
  } else {
    L = pow<static_rational<1, 3>>(1.0 / number_density /
                                   si::constants::codata::N_A);
    VLOG(3) << "Low energy free flying path length with m_1 " << m_1 << ", m_2 "
            << m_2 << ", reduced_energy " << reduced_energy
            << ", screening_length " << screening_length
            << ", and number_density " << number_density << " with result "
            << L;
  }
  return L;
}

length_quantity Ion::collision_diameter(dimensionless_quantity z_1,
                                        dimensionless_quantity z_2,
                                        mass_quantity rd_mass,
                                        velocity_quantity speed) const {
  auto result =
      4 * z_1 * z_2 * e_statcoulomb * e_statcoulomb / (rd_mass * speed * speed);
  VLOG(2) << "Collision diameter given z_1 " << z_1 << ", z_2 " << z_2
          << " reduced mass " << rd_mass << ", and speed " << speed << " is "
          << result;
  return result;
}

// TODO: Fix magnitude error. This code reports closest approach on the
// order of meters. Find out why.
length_quantity Ion::closest_approach(dimensionless_quantity z_1,
                                      dimensionless_quantity z_2,
                                      energy_quantity cm_energy,
                                      length_quantity impact_param,
                                      length_quantity coll_diameter) const {
  // Potential function
  auto F = [&](length_quantity closest_approach) {
    return 1 - screening_potential(closest_approach, z_1, z_2) / cm_energy -
           pow<2>(impact_param / closest_approach);
  };
  // Derivative of potential function
  auto dF = [&](length_quantity closest_approach) {
    return -screening_potential_derivative(closest_approach, z_1, z_2) /
               cm_energy +
           2.0 * impact_param * impact_param /
               pow<static_rational<3>>(closest_approach);
  };
  auto old_result =
      impact_param; // Initial guess, adjust if encountering convergence issues
  VLOG(3) << "Closest approach initial guess " << old_result;
  auto old_pot = F(old_result);
  auto result = old_result - old_pot / dF(old_result); // First iteration
  auto pot = F(result);
  // Newtonian iteration
  size_t iterations = 0;
  constexpr size_t max_iterations = 100; // If encountering convergence errors,
                                         // increase. Will decrease performance.
  constexpr double rel_tolerance =
      1e-3; // Threshold for relative tolerance. Increase if encountering
            // convergence issues.
  while (iterations < max_iterations) {
    auto rel_diff = abs(result - old_result) / result;

    if (rel_diff < rel_tolerance) {
      VLOG(2) << "Closest approach found after " << iterations
              << " iterations. Result " << result;
      return result;
    }

    auto d_pot = dF(old_result);
    old_pot = pot;
    pot = F(result);

    // Based on verbose log inspection, this is unlikely to occur.
    if ((old_pot < 0.0 && pot > 0.0) || (old_pot > 0.0 && pot < 0.0)) {
      // Go into binary search (Solves oscillation problem)
      size_t binary_search_iterations = 0;

      while (true) {
        if (iterations > max_iterations) {
          break;
        }
        if (rel_diff < rel_tolerance) {
          VLOG(2) << "Closest approach found after " << iterations << " and "
                  << binary_search_iterations << " binary search iterations."
                  << " iterations. Result " << result;
          rel_diff = abs(result - old_result) / result;
          return result;
        }
        auto mid_result = old_result + (result - old_result) / 2.0;
        auto mid_pot = F(mid_result);

        VLOG(3) << "Binary search old_result " << old_result << " old_pot "
                << old_pot << " mid_result " << mid_result << " mid_pot "
                << mid_pot << " result " << result << " pot " << pot;
        if (copysign(old_pot, mid_pot) == old_pot) {
          // If old_pot and mid_pot have the same sign
          old_result = mid_result; // Search the "right" side
          old_pot = mid_pot;
          VLOG(3) << "Searching pot side";
        } else {
          result = mid_result; // Search the "left" side
          pot = mid_pot;
          VLOG(3) << "Searching old_pot side";
        }
        binary_search_iterations++;
      }
    }

    old_result = result;
    result = old_result - pot / d_pot;
    iterations++;

    VLOG(3) << "Zeroing function value " << pot << ", derivative " << d_pot;
    VLOG(3) << "Newtonian iteration " << iterations << ". Previous result "
            << old_result << ", current result " << result << ". Tolerance "
            << rel_tolerance << ", relative difference " << rel_diff;
  }

  // TODO: Write more graceful code to handle this. And throw an exception to be
  // handled by the GUI if convergence doesn't occur.
  LOG(ERROR) << "Convergence error. Please adjust closest approach parameters. "
                "Previous result "
             << old_result << ", current result " << result;

  return result;
}

length_quantity Ion::radius_of_curvature(length_quantity radius,
                                         energy_quantity cm_energy,
                                         dimensionless_quantity z_1,
                                         dimensionless_quantity z_2) const {
  auto result = 2.0 * abs(cm_energy - screening_potential(radius, z_1, z_2)) /
                (-screening_potential_derivative(radius, z_1, z_2));
  VLOG(2) << "Radius of curvature for radius " << radius << " cm_energy "
          << cm_energy << " z_1 " << z_1 << " z_2 " << z_2 << " has result "
          << result;
  return result;
}

// }}}

// Electron function implementations{{{
void Electron::fire() try {
  // TODO: Implement Electron simulation
  throw std::logic_error("Electron simulation is not implemented");
} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
} // }}}

// Ion function implementations // {{{
void Ion::fire() try {
  LOG(INFO) << "Firing ion with initial energy " << velocity_.energy_;
  const auto ion_stopping_energy =
      simulation_.get_settings(&Simulation::Settings::ion_stopping_energy_);
  auto current_layer_pair = simulation_.get_volume().get_layer(coordinate_.z_);
  const Layer &current_layer = *(current_layer_pair.first);

#ifdef NDEBUG /*{{{*/
#else
  // Grad an iterator to a view of the first
  auto comp_view = current_layer.get_relative_compositions().begin();
  for (size_t i = 0; i < current_layer.get_number_of_components(); i++) {
    auto direct_composition = current_layer.get_relative_composition(i);
    auto viewed_composition = *(comp_view++);
    VLOG(2) << "Index: " << i << " has directly measured composition of "
            << direct_composition << " view-based composition of "
            << "Relative (view): " << viewed_composition;
    assert(direct_composition == viewed_composition);
  }
#endif /*}}}*/

  while (velocity_.energy_ > ion_stopping_energy) {
    // TODO:
    const size_t atom_index =
        current_layer.get_discrete_distribution()(random_number_generator_);
    const auto layer_properties = current_layer.get_property(atom_index);

    auto z_1 = properties_.charge_;
    auto z_2 = layer_properties.charge_;
    auto m_1 = properties_.mass_;
    auto m_2 = layer_properties.mass_;
    auto number_density = current_layer.get_number_density();
    auto energy = velocity_.energy_;

    // TODO: Implement simulation calculations
    //
    // 1. Subtract electronic stopping energy
    velocity_.energy_ = electronic_stopping_energy(
        z_1, m_1, energy, number_density, layer_properties);

    VLOG(2) << "New energy " << velocity_.energy_;
    auto speed = speed_from_energy(energy, m_1);
    auto rd_mass = reduced_mass(m_1, m_2);
    auto c_mass_energy = cm_energy(m_1, speed);
    auto screen_length = screening_length(z_1, z_2);
    auto rd_energy = reduced_energy(screen_length, c_mass_energy, z_1, z_2);
    auto path_length = free_flying_path_length(m_1, m_2, rd_energy,
                                               screen_length, number_density);
    auto i_param = impact_parameter(number_density, path_length, rd_energy);

    auto coll_diameter = collision_diameter(z_1, z_2, rd_mass, speed);
    auto closest_appr =
        closest_approach(z_1, z_2, c_mass_energy, i_param, coll_diameter);
    auto rad_curv = radius_of_curvature(closest_appr, c_mass_energy);

    // TODO: Implement derivative of screening potential

    // 2. Calculate recoil energy and velocity
    // 3. Calculate new coordinate (push old coordinate to vector)
    // 4. Determine if sputtering occured
    // 5. Check if damage cascade occurs
    //    a. If so, if energy difference is larger than displacement energy,
    //    create a cascade particle and push it to the particles_ vector
  }
} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
}

length_quantity
Ion::impact_parameter(number_density_quantity number_density,
                      length_quantity length,
                      dimensionless_quantity reduced_energy) const {
  length_quantity result;

  auto random_number = uniform_distribution_(random_number_generator_);
  // TODO: Fix this. Fix proper random numbers and calculation. High energy
  // gives ridiculous results. Research e >> 10 on 7-8 in SRIM book.
  if (reduced_energy > 10.0) {
    result = sqrt(-log(random_number) /
                  (pi * number_density * length * si::constants::codata::N_A));
    VLOG(2) << "Impact parameter at high energy for number density "
            << number_density << ", length " << length
            << ", and reduced energy " << reduced_energy << " is " << result;
  } else {
    result = sqrt(random_number /
                  (pi * pow<static_rational<2, 3>>(
                            number_density * si::constants::codata::N_A)));
    VLOG(2) << "Impact parameter at low energy for number density "
            << number_density << ", length " << length
            << ", and reduced energy " << reduced_energy << " is " << result;
  }
  return result;
}

length_quantity
Ion::interatomic_spacing(number_density_quantity number_density) const {
  return root<-3>(number_density * constants::N_A);
};

energy_quantity
Ion::electronic_stopping_energy(dimensionless_quantity charge,
                                mass_quantity mass, energy_quantity energy,
                                number_density_quantity number_density,
                                const Properties &properties) const try {
  VLOG(2) << "Calculating ion electronic stopping energy with charge " << charge
          << ", mass " << mass << ", and energy " << energy;

  const auto c_1 =
      1.212 * root<2>(constants::m_u) * root<2>(electron_volt) / angstrom;
  VLOG(3) << "Value of c_1 " << c_1;
  const auto k_l = c_1 * pow<static_rational<7, 6>>(charge) *
                   properties.charge_ /
                   (pow<static_rational<3, 2>>(
                        pow<static_rational<2, 3>>(charge) +
                        pow<static_rational<2, 3>>(properties.charge_)) *
                    root<2>(mass));
  VLOG(3) << "Value of k_l " << k_l;
  const auto stopping_energy = k_l * root<2>(energy);
  VLOG(3) << "Value of stopping_energy " << stopping_energy;
  const auto c_2 = 1.59 * pow<3>(angstrom);
  VLOG(3) << "Value of c_2 " << c_2;
  const auto travel_length = interatomic_spacing(number_density);
  VLOG(3) << "Value of travel_length " << travel_length;
  const auto energy_loss =
      c_2 * travel_length * number_density * constants::N_A * stopping_energy;
  VLOG(3) << "Value of energy_loss " << energy_loss;
  return energy - energy_loss;
} catch (...) {
  rethrow(EXCEPTION_MESSAGE(""));
} // }}}

} // namespace common
} // namespace amcset
